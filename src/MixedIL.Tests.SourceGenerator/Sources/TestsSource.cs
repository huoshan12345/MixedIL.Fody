using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;

namespace MixedIL.Tests.SourceGenerator.Sources
{
    public static class TestsSource
    {
        internal const string RootNamespace = "MixedIL.Tests.Weaving";
        internal const string GeneratedFilesHeader = "// <auto-generated />";
        internal static readonly string ReturnTypeName = "StringTestResult";

        internal static (string FileName, string Code) Generate(INamedTypeSymbol type, string className)
        {
            var usings = new List<string> { "Xunit", TestsSourceGenerator.AssemblyName };

            using var builder = new SourceBuilder()
                                .WriteLine(GeneratedFilesHeader)
                                .WriteLine()
                                .WriteUsings(usings)
                                .WriteLine();

            // Namespace declaration
            builder.WriteLine($"namespace {RootNamespace}")
                   .WriteOpeningBracket();

            // Class declaration
            builder.WriteLine($"public class {className} : ClassTestsBase")
                   .WriteOpeningBracket();

            builder.WriteLine($"protected override string ClassName => nameof({type.Name});");

            var methods = type.GetMembers().OfType<IMethodSymbol>();
            foreach (var method in methods.Where(m => m.DeclaredAccessibility == Accessibility.Public && m.MethodKind == MethodKind.Ordinary))
            {
                if (method.ReturnType.Name != ReturnTypeName)
                    throw new InvalidOperationException($"Expected return type {ReturnTypeName} for method {method.Name}, but got {method.ReturnType.Name}");

                builder.WriteLine("[Fact]")
                       .WriteLine($"public void {method.Name}()")
                       .WriteOpeningBracket();

                builder.WriteLine($"var (expected, actual) = ((string, string))GetInstance().{method.Name}();")
                       .WriteLine("Assert.Equal(expected, actual);")
                       .WriteClosingBracket();
            }

            // End class declaration
            builder.WriteClosingBracket();

            // Standard Class declaration
            var classNameOfStandard = className + "Standard";
            builder.WriteLine($"public class {classNameOfStandard} : {className}")
                   .WriteOpeningBracket()
                   .WriteLine("protected override bool NetStandard => true;")
            // End class declaration
            .WriteClosingBracket();

            // End namespace declaration
            builder.WriteClosingBracket();

            var str = builder.ToString();
            return ($"{className}.g.cs", str);
        }
    }
}
